# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: osmosis/epochs/genesis.proto, osmosis/epochs/query.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class EpochInfo(betterproto.Message):
    """
    EpochInfo is a struct that describes the data going into a timer defined by
    the x/epochs module.
    """

    # identifier is a unique reference to this particular timer.
    identifier: str = betterproto.string_field(1)
    # start_time is the time at which the timer first ever ticks. If start_time
    # is in the future, the epoch will not begin until the start time.
    start_time: datetime = betterproto.message_field(2)
    # duration is the time in between epoch ticks. In order for intended behavior
    # to be met, duration should be greater than the chains expected block time.
    # Duration must be non-zero.
    duration: timedelta = betterproto.message_field(3)
    # current_epoch is the current epoch number, or in other words, how many
    # times has the timer 'ticked'. The first tick (current_epoch=1) is defined
    # as the first block whose blocktime is greater than the EpochInfo
    # start_time.
    current_epoch: int = betterproto.int64_field(4)
    # current_epoch_start_time describes the start time of the current timer
    # interval. The interval is (current_epoch_start_time,
    # current_epoch_start_time + duration] When the timer ticks, this is set to
    # current_epoch_start_time = last_epoch_start_time + duration only one timer
    # tick for a given identifier can occur per block. NOTE! The
    # current_epoch_start_time may diverge significantly from the wall-clock time
    # the epoch began at. Wall-clock time of epoch start may be >>
    # current_epoch_start_time. Suppose current_epoch_start_time = 10, duration =
    # 5. Suppose the chain goes offline at t=14, and comes back online at t=30,
    # and produces blocks at every successive time. (t=31, 32, etc.) * The t=30
    # block will start the epoch for (10, 15] * The t=31 block will start the
    # epoch for (15, 20] * The t=32 block will start the epoch for (20, 25] * The
    # t=33 block will start the epoch for (25, 30] * The t=34 block will start
    # the epoch for (30, 35] * The **t=36** block will start the epoch for (35,
    # 40]
    current_epoch_start_time: datetime = betterproto.message_field(5)
    # epoch_counting_started is a boolean, that indicates whether this epoch
    # timer has began yet.
    epoch_counting_started: bool = betterproto.bool_field(6)
    # current_epoch_start_height is the block height at which the current epoch
    # started. (The block height at which the timer last ticked)
    current_epoch_start_height: int = betterproto.int64_field(8)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the epochs module's genesis state."""

    epochs: List["EpochInfo"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryEpochsInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryEpochsInfoResponse(betterproto.Message):
    epochs: List["EpochInfo"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryCurrentEpochRequest(betterproto.Message):
    identifier: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryCurrentEpochResponse(betterproto.Message):
    current_epoch: int = betterproto.int64_field(1)


class QueryStub(betterproto.ServiceStub):
    async def epoch_infos(self) -> "QueryEpochsInfoResponse":

        request = QueryEpochsInfoRequest()

        return await self._unary_unary(
            "/osmosis.epochs.v1beta1.Query/EpochInfos", request, QueryEpochsInfoResponse
        )

    async def current_epoch(
        self, *, identifier: str = ""
    ) -> "QueryCurrentEpochResponse":

        request = QueryCurrentEpochRequest()
        request.identifier = identifier

        return await self._unary_unary(
            "/osmosis.epochs.v1beta1.Query/CurrentEpoch",
            request,
            QueryCurrentEpochResponse,
        )


class QueryBase(ServiceBase):
    async def epoch_infos(self) -> "QueryEpochsInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def current_epoch(self, identifier: str) -> "QueryCurrentEpochResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_epoch_infos(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.epoch_infos(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_current_epoch(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "identifier": request.identifier,
        }

        response = await self.current_epoch(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.epochs.v1beta1.Query/EpochInfos": grpclib.const.Handler(
                self.__rpc_epoch_infos,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryEpochsInfoRequest,
                QueryEpochsInfoResponse,
            ),
            "/osmosis.epochs.v1beta1.Query/CurrentEpoch": grpclib.const.Handler(
                self.__rpc_current_epoch,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryCurrentEpochRequest,
                QueryCurrentEpochResponse,
            ),
        }
